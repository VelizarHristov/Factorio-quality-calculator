package preprocessing

import io.Source.fromFile
import java.nio.file.{Paths, Files}
import java.nio.charset.StandardCharsets

/** Transform a larger dataset to keep just the fields that we use
  *
  * Uses the data from FactorioLab at https://github.com/factoriolab/factoriolab/blob/main/src/data/spa/data.json
  * Only keeps the fields that we use (or might use in the future)
  * Writes to data.json, which is then used by our app
  *
  * Properties of the data:
  *     - Root keys: version, icons, items, recipes, locations, defaults
  *     - From these, I expect to need "icons" in the future
  *     - The first item in "items":
  *         {"id":"wooden-chest","name":"Wooden chest","category":"logistics","stack":50,"row":0}
  *     - The first item in "recipes":
  *         {"id":"wooden-chest","name":"Wooden chest","category":"logistics","row":0,
  *          "time":0.5,"producers":["assembling-machine-1","assembling-machine-2","assembling-machine-3"],
  *          "in":{"wood":2},"out":{"wooden-chest":1},"disallowedEffects":["productivity"]}
  *     - All keys which might occur in "items": id, name, category, stack, row, belt, pipe, cargoWagon, fluidWagon, machine, beacon, module, fuel, iconText, icon, technology
  *     - All keys which might occur in "recipes": id, name, category, row, time, producers, in, out, disallowedEffects, flags, locations, catalyst, icon, cost, iconText
  *     - Information about some keys:
  *         - id - it's unique, unlike name
  *         - category - if it's "research" then we don't want it, otherwise it seems irrelevant - it probably determines where to place it in the recipe selection screen in-game. See below for all categories.
  *         - stack - stack size
  *         - row - an integer, probably determines where it's placed in the recipe selection UI
  *         - belt, pipe, cargoWagon, fluidWagon - only present if the entity is one of these; determines speed or stack size (pipe = 1200 for the pump entity)
  *         - flags - most didn't seem relevant to my app (except for "mining"); it's generated by Factoriolab, for more info look at that repository
  *         - cost - only for "recipes" that are for mining a raw product, probably determines how much of the raw resource gets depleted
  *     - List of categories (they all appear for both items and recipes, except for "other", which shows up only for recipes):
  *         logistics, production, intermediate-products, space, combat, fluids, other, technology
  */
@main
def processJson(): Unit =
    val jsonStr = fromFile("factoriolab_data.json").mkString
    val json = ujson.read(jsonStr).obj
    val recipeKeys = Set("id", "name", "time", "producers", "in", "out", "disallowedEffects", "catalyst")
    val itemKeys = Set("id", "name", "machine", "beacon", "module")
    val itemFieldKeys = Map(
        "machine" -> Set("speed", "modules"),
        "beacon" -> Set("effectivity", "modules", "profile"),
        "module" -> Set("consumption", "speed", "productivity", "quality")
    )
    val recipes = json("recipes").arr
        .filter(recipe =>
            recipe("category").str != "technology" &&
            (!recipe.obj.keySet.contains("flags") || !recipe("flags").arr.exists(_.str == "mining"))
        )
        .map(_.obj.view.filterKeys(recipeKeys.contains))
    // also includes all production machines since they all come from recipes in vanilla SA
    val idsInRecipes = recipes.flatMap(recipe =>
        (recipe("in").obj ++ recipe("out").obj).keySet
    ).distinct.toSet
    val items = json("items").arr
        .filter(item => idsInRecipes.contains(item("id").str))
        .map:
            item =>
                val nextItem = item.obj.view.filterKeys(itemKeys.contains).map: (k, v) => 
                    val newV: ujson.Value =
                        if itemFieldKeys.contains(k) then
                            v.obj.view.filterKeys(itemFieldKeys(k).contains)
                        else
                            v
                    (k, newV)
                val nextItemObj = nextItem.obj
                nextItemObj("isFluid") = item("category").str == "fluids"
                nextItemObj

    val res = ujson.Obj(
        "recipes" -> recipes,
        "items" -> items
    )
    Files.write(Paths.get("data.json"), res.toString.getBytes(StandardCharsets.UTF_8))
